# java并发编程入门
### 基本概念
#####  并发： 同时拥有俩个或者多个线程，如果线程在单核处理器上运行，多个线程将交替的换入或者换出内存，这些线程是同时 "存在" 的，每个线程都处于执行过程中的某个状态，如果运行在多核处理器上，此时程序中的每个线程都将分配到一个处理器核上，因此可以同时运行
##### 高并发： 高并发( High Concurrency )是互联网分布式系统架构设计中必须考虑的因素之一，它通常是指，通过设计保证系统能够同时并行处理很多请求
##### 并发与高并发 的区别：
###### 1、并发：多个线程操作相同的资源，保证线程安全， 合理使用资源
###### 2、高并发： 服务能同时处理很多请求，提高程序性能 
## 并发编程的基础
### CPU多级缓存
##### 为什么需要CPU cache ： 
    cpu的频率太快了，快到主存跟不上，这样在处理时钟周期内，CPU常常需要等待主存，浪费资源。
    所以cache的出现，是为了缓解CPU和内存之间素的的不匹配问题
    (结构 : cpu -> cache -> memory)
    
##### CPU cache有什么意义 ：
    1、时间局限性：如果某个数据被访问， 那么在不久的将来它很可能被再次访问
    2、空间局限性：如果某个数据被访问， 那么与它相邻的数据很快也可能被访问 
    
##### CPU多级缓存 - 缓存一致性 ( MESI )协议
    用于保证多个CPU cache之间缓存共享数据的一致
    
##### CPU多级缓存 - 乱序执行优化
    处理器为条运算速度而做出的为被代码原有顺序的优化
    
### Java内存模型( java Memory Model, JMM )
##### Java内存模型规范: 
    规定了一个线程如何核实看到由其他线程修改后的共享变量的值，以及在必须是如何同步的访问共享变量。
##### 堆：
###### java中的堆是一个运行时数据区，堆是由垃圾回收来负责的，
    堆的优势是： 可以动态的分配内存大小，生存期也不必事先告诉编译器，因为它是在运行时动态分配内存的，java的垃圾收集器会自动搜索这些不再需要的数据
    堆的缺点是： 由于是在运行时动态分配内存，因此存取速度相对慢一些
##### 栈：
    栈的优势是： 栈的存取速度比堆快一些，仅次于计算机中的寄存器，栈的数据是可以共享的，
    栈的缺点是： 栈的数据大小与生存期必须是确定的，缺乏一些灵活性，
###### 栈中主要存放一些基本类型的变量(boolean、byte、char、short、int、float、double、long) 和对象句柄，
###### java内存模型 
    要求调用栈和本地变量(局部变量)存放在线程栈上，对象存放在堆上。
    方法中的本地变量(局部变量)也是存在线程栈上，即使对象是存在于堆上
    一个对象的成员变量跟随对象一起存在于堆上，（不论这个变量是基本数据类型还是引用数据类型）
    静态成员变量跟随类的定义一起存在于堆上
##### 注意: 
###### 当一个线程访问一个对象， 就可以访问这个对象的成员变量，
###### 当两个线程同时访问一个对象的同一个方法，并且该方法中还调用了该对象的成员变量，那么这俩个线程就会用同时拥有这个对象的成员变量的拷贝，这时候会发生问题

##### Java内存模型 - 同步八种操作
###### 1、lock(锁定) : 作用于主内存的变量， 把一个变量标示为一条线程独占状态
###### 2、unlock(解锁) : 作用于主内存的变量， 把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定
###### 3、read(读取) : 作用于主内存的变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用
###### 4、load(载入) : 作用于工作内存的变量，它把read操作从主内存中得到的变量值放入到工作内存的变量副本中
###### 5、use(使用) : 作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎
###### 6、assign(赋值) : 作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量
###### 7、store(存储) : 作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后额write操作
###### 8、write(写入) : 作用于主内存的变量， 它把store操作从工作内存中一个变量的值传送到主内存的变量中

##### Java内存模型 - 同步规则
###### 1、如果要把一个变量从主内存中赋值到工作内存， 就需要按顺序的执行read和load操作， 如果把变量从工作内存中同步回主内存中，就要按顺序地执行store和write操作。但Java内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行
###### 2、不允许read和load、store和write操作之一单独出现
###### 3、不允许一个线程丢弃它的最近assign的操作， 即变量在工作内存中改变了之后必须同步到主内存中
###### 4、不允许一个线程无原因地 (没有发生过任何assign操作) 把数据从工作内存同步回主内存中
###### 5、一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化 (load 或 assign ) 的变量，即就是对一个变量实施use和store操作之前，必须先执行过了一个assign和load'操作
###### 6、一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次， 多次执行lock后， 只有执行相同次数的unlock操作，变量才会被解锁。lock和unlock必须成对出现
###### 7、如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值
###### 8、如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个呗其他线程锁定的变量
###### 9、对一个变量执行unlock操作之前，必须先把此变量同步到主内存中(执行store和write操作) 
### 并发的优势与风险
##### 优势:
###### 速度：
    系统可以同时处理多个请求，响应更快；
    复杂的操作可以分成多个进程同时进行
###### 设计：
    程序设计在某些情况下更简单，也可以有更多的选择
###### 资源引用
    CPU能够在等待IO时做一些其他的事情
    
##### 风险：
###### 安全性:
    多个线程共享数据时可能会产生与期望不相符的结果
###### 活跃性:
    某个操作无法继续进行下去时，就会发生活跃性问题，比如死锁，饥饿等问题
###### 性能:
    线程过多是会使得：CPU频繁切换，调度时间增多；同步机制；消耗过多内存
    
### 并发模拟
##### 1、Postman ： HTTP请求模拟工具
##### 2、Apache Bench (AB) ： Apache 附带的工具， 测试网站性能
    ApacheBench 是 Apache 服务器自带的一个web压力测试工具，简称ab。ab又是一个命令行工具，
    对发起负载的本机要求很低，根据ab命令可以创建很多的并发访问线程，模拟多个访问者同时对
    某一URL地址进行访问，因此可以用来测试目标服务器的负载压力。总的来说ab工具小巧简单，
    上手学习较快，可以提供需要的基本性能指标，但是没有图形化结果，不能监控。
###### AB 参数配置 https://blog.csdn.net/water_tone/article/details/79003059
    ab -n 1000 -c 50 http://localhost:8080/test 
    -n 本次测试总是为多少个
    -c 本次测试的并发数为多少个 
###### 测试结果讲解
    Concurrency Level:      50                                                          // 测试的并发量为50
    Time taken for tests:   0.287 seconds                                               // 测试用的时间
    Complete requests:      1000                                                        // 完成的请求数
    Failed requests:        0                                                           // 失败的请求数
    Total transferred:      136000 bytes                                                // 所有请求的响应数据的长度总和，包括每个Http响应数据的头信息和正文数据的长度，
                                                                                           这里不包括Http请求数据的长度，仅仅展示web服务器流向用户应用层数据的长度
    HTML transferred:       4000 bytes                                                  // 所有请求的响应数据中正文数据的长度总和(总长度-头信息)
    Requests per second:    3481.89 [#/sec] (mean)                                      // 吞吐率 与并发数相关 (Complete requests) / (Time token for tests)
    Time per request:       14.360 [ms] (mean)                                          // 用户平均请求等待时间
    Time per request:       0.287 [ms] (mean, across all concurrent requests)           // 服务器平均请求等待时间
    Transfer rate:          462.44 [Kbytes/sec] received                                // 请求在单位时间内从服务器获取的数据长度  (Total transferred) / (Time taken for tests)
    
    Connection Times (ms)
                  min  mean[+/-sd] median   max
    Connect:        0    0   0.4      0       1
    Processing:     2   14   1.8     14      17
    Waiting:        1    8   3.7      8      16
    Total:          2   14   1.8     14      17
    
    Percentage of the requests served within a certain time (ms)
      50%     14
      66%     14
      75%     15
      80%     15
      90%     15
      95%     16
      98%     16
      99%     16
     100%     17 (longest request)
##### 3、JMeter ： Apache组中开发的压力测试工具
###### 比AB更强大， 用的最多的
##### 4、代码 ： Semaphore、CountDownLatch等 对并发的模拟 
###### CountDownLatch类 向下减的 可以阻塞线程， 当线程满足一定的条件才可以向下执行
    countDownLatch这个类使一个线程等待其他线程各自执行完毕后再执行。
    是通过一个计数器来实现的，计数器的初始值是线程的数量。每当一个线程执行完毕后，计数器的值就-1，
    当计数器的值为0时，表示所有线程都执行完毕，然后在闭锁上等待的线程就可以恢复工作了。
###### Semaphore 信号量  也可以阻塞线程

### 线程安全性
##### 定义：当多个线程访问某个类时，不管运行时环境采用何种调用方式或者这些进程将如何交替执行，并且在主调代码中不需要任何额外的同步或协同，这个类都能表现出正确的行为，那么就称这个类是线程安全的
##### 线程安全性主要体现在三个方面: 
###### 1、原子性: 提供了互斥访问，同一时刻只能有一个线程来对他进行操作
###### 2、可见性: 一个线程对主内存的修改可以及时的被其他线程观察到
###### 3、有序行: 一个线程观察其他线程中的指令执行顺序，由于指令重排序的存在，该观察结果一般杂乱无序

##### 原子性 - Atomic包
###### AtomicXXX : CAS、 Unsafe.compareAndSwapInt
###### CAS原理实现
    public final int getAndAddInt(Object var1, long var2, int var4) {
            int var5;
            do {
                // 从底层取到当前对象变量的值
                var5 = this.getIntVolatile(var1, var2);
                // compareAndSwapInt 判断当前var1对象对应的值var2是否与主存取出的var5的值相等，
                // 如果相等就更新主存当前对象对应的值var5为var5 + var4，并跳出循环 
                // 如果不相等就更新当前线程缓存中（工作内存）主存对象值的拷贝值var2为var5，然后再循环判断
            } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));
    
            return var5;
        }
    
###### ActomicLong、 LongAdder(jdk1.8)
###### LongAdder 优点：
    因为CAS底层实现是在一个while死循环内，不断的尝试修改目标值，直到修改成功，在竞争不激烈的时候，它修改成功的概率很高，如果竞争激烈额话，它修改失败的概率就很高，这个时候性能就会受到影响
    对于普通类型的long、double类型，JVM允许将64位的读操作或者写操作，拆成俩个32位操作
###### LongAdder原理实现：
    是将热点数据分离，比如可以将AtomicLong内部核心数据value，分离成一个数组，每个线程访问时，通过Hash等算法，映射到其中一个数字进行计数，最终的计数结果则为这个数组的求和累加，
    其中热点数据value会被分离成多个单元的shell，每个shell独自维护内部的值，当前对象的值由所有shell累计合成，这样就进行了有效的分离并提高了并行度，
    这样一来LongAdder就在AtomicLong的基础上将单点的压力分担在各个节点上，
    在低并发的时候通过对底层base的更新达到和AtomicLong一样的效果，
    在高并发的时候通过分担节点来提高性能
    
    缺点: 
        在统计的时候，如果有并发更新，统计的结果会有一些误差
        
###### AtomicReference、AtomicReferenceFieldUpdater 
###### AtomicStampReference : CAS 的 ABA 问题
    什么是CAS的ABA问题？
        ABA问题是指在CAS操作的时候其他线程将变量的值A改成了B，然后有改成了A，
        本线程在CAS操作的时候发现当前底层变量的值和工作内存中的值相等，进而进行了更新操作，
        这个时候实际上值已经被其他线程修改过， 这与CAS本身的设计思想是不相符的    
    ABA的解决思路：
        每次变量更新的时候将变量的版本号加1，1A -> 2B -> 3A 
###### AtomicStameReference源码
    public boolean weakCompareAndSet(V   expectedReference,
                                         V   newReference,
                                         // 期望的版本号
                                         int expectedStamp,
                                         // 新的版本号
                                         int newStamp) {
            return compareAndSet(expectedReference, newReference,
                                 expectedStamp, newStamp);
        }
        
###### AtomicLongArray
    和 AtomicLong方法基本类似， 只是会多加了一个索引值参数
###### 实例 AtomicBoolean 中的compareAndSet(boolean expect, boolean update) 
    